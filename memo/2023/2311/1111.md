```
{
id : 3rd app에서 제공하는 사용자 식별용 id,
name : 이름,
이메일 : 이메일,
사진 : 사진 url
}
```

id는 db에 검색 후 없으면 추가, 있으면 무시

name, 이메일, 사진은 전송하되, id와 함께 encrypt해서 보낸다.

어떻게 해야 괜찮은 암호화가 될까..

그냥 id+name+email+pic해서 하나의 string으로 묶고 이걸 암호화해준다.

이걸 s라고 하겠음

그럼 프론트로 보낼 때는

{name, email, pic, s}를 보낸다.

반대로 프론트에서 요청이 들어와 검증할 때는

s를 까서 id를 보고, 이게 db에 있는지 확인하면 될 것 같음.

//

sql 구문 같은게 수가 어느 정도 쌓였는데 너무 산발적으로 존재한다.

나중에 수정할 일이 생기면 문제가 있을 수도 있을텐데..

sql 재사용되는 코드는 모아두는게 좋을까?

//

id가 유저 아이디가 아니었음..

어플리케이션의 id였음.. 어떡하지..

싸그리 바꿔야겠네.. 큰일이다..

//

에휴... 이걸 먼저 확인헀어야 했는데..

이렇게 된거 그냥 리팩토링이나 마저 하자.

라우터와 함수들을 구글 카카오가 어차피 다른 클래스 같은 이름 함수들을 호출하므로

이걸 하나로 합칠 수 있을 것 같음.

Strategy 패턴을 사용해보자.

# Strategy

객체들이 할 수 있는 행위 각각에 대해 전략 class를 생성하고, 유사한 행위들을 캡슐화하는 인터페이스를 정의하며,

객체의 액션을 동적으로 바꾸고 싶은 경우, 액션을 직접 수정하지 않고 전략을 바꿔 행위를 유연하게 확장하는 방법을 의미한다.

즉, 객체가 할 수 있는 액션 각각을 전략으로 만들어 놓고, 동적인 액션 수정이 필요한 경우 전략을 바꿔 액션의 수정이 가능하도록 만든 패턴

쉽게 말하면 메서드를 중심으로 class를 짠다고 생각하면 되나..?

이미 abstract factory로 구현한 부분까지 수정할 필요는 없을 것 같고..

컨트롤러랑 서비스부분만 잘 수정해보자.
